///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MRDT Differential Joint 2020
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef ROVE_DIFF_BRUSHLESS
#define ROVE_DIFF_BRUSHLESS

#include "RovesODrive.h"
#include "RoveUsDigiMa3Pwm.h"
#include "RoveBoardMap.h"
#include "RoveWatchdog.h"
#include "RovePid.h"
#include "Energia.h"

#include <stdint.h>

class RoveDifferentialJointBrushless
{
  public:

    const int MAX_SPEED_REVERSE;
    const int MAX_SPEED_FORWARD;
    
    RoveUsDigiMa3Pwm TiltEncoder;
    RoveUsDigiMa3Pwm TwistEncoder;

    RovePidFloats TiltPid;
    RovePidFloats TwistPid;

    RovesODrive Joint;

    uint8_t LS_UPPER = INVALID;
    uint8_t LS_LOWER = INVALID;

    int left_limit = 0;
    int right_limit = 0;

    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    //Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    RoveDifferentialJointBrushless(HardwareSerial* odrive_serial, uint8_t tilt_encoder_pin, uint8_t twist_encoder_pin);

    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    //Limit Switch Handling
    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    void attachLimitSwitches(uint8_t upper_pin, uint8_t lower_pin);
    //returns whether or not the Limit switch is pressed (if we are moving past that given limit)
    bool isLowerLSPressed();
    bool isUpperLSPressed();
    //sets angle limits to use as hardstops for movement on an axis without limit switches
    void setTwistLimits(int left_lim, int right_lim);

    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    //Handle ODrive errors 
    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    handleError();

    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    //Calculations
    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    void tiltTwistDecipercent( int tilt_decipercent, int twist_decipercent);
    bool atTiltLimit(int drive_speed);
    bool atTwistLimit(int drive_speed, uint32_t current_angle);
    //TODO: move_to_position wrapper based off of commanded positions and absolute/incremental encoder output

    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    //Encoder Handling
    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    bool TwistEncoderDisconnect();
    bool TiltEncoderDisconnect();

};

#endif // ROVE_DIFF
